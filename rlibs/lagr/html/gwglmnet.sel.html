<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Bandwidth selection in a GW-GLM model (bandwidth in terms of...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="R.css">
</head><body>

<table width="100%" summary="page for gwglmnet.sel {lagr}"><tr><td>gwglmnet.sel {lagr}</td><td align="right">R Documentation</td></tr></table>

<h2>
Bandwidth selection in a GW-GLM model (bandwidth in terms of nearest neighbors or distance).
</h2>

<h3>Description</h3>

<p>Bandwidth selection in a GW-GLM model (bandwidth in terms of nearest neighbors or distance).
</p>


<h3>Usage</h3>

<pre>
gwglmnet.sel(formula, data = list(), coords, adapt = FALSE, nearest.neighbors = FALSE, gweight = gwr.Gauss, s, method = "cv", verbose = FALSE, longlat = FALSE, family, weights, tol = .Machine$double.eps^0.25)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>coords</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>adapt</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>nearest.neighbors</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>gweight</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>s</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>longlat</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>


</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wesley Brooks
</p>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (formula, data = list(), coords, adapt = FALSE, nearest.neighbors = FALSE, 
    gweight = gwr.Gauss, s, method = "cv", verbose = FALSE, longlat = FALSE, 
    family, weights, tol = .Machine$double.eps^0.25) 
{
    if (!is.logical(adapt)) 
        stop("adapt must be logical")
    if (is(data, "Spatial")) {
        if (!missing(coords)) 
            warning("data is Spatial* object, ignoring coords argument")
        coords &lt;- coordinates(data)
        if ((is.null(longlat) || !is.logical(longlat)) &amp;&amp; !is.na(is.projected(data)) &amp;&amp; 
            !is.projected(data)) {
            longlat &lt;- TRUE
        }
        else longlat &lt;- FALSE
        data &lt;- as(data, "data.frame")
    }
    if (is.null(longlat) || !is.logical(longlat)) 
        longlat &lt;- FALSE
    if (missing(coords)) 
        stop("Observation coordinates have to be given")
    mf &lt;- match.call(expand.dots = FALSE)
    m &lt;- match(c("formula", "data", "weights"), names(mf), 0)
    mf &lt;- mf[c(1, m)]
    mf$drop.unused.levels &lt;- TRUE
    mf[[1]] &lt;- as.name("model.frame")
    mf &lt;- eval(mf, parent.frame())
    mt &lt;- attr(mf, "terms")
    dp.n &lt;- length(model.extract(mf, "response"))
    weights &lt;- as.vector(model.extract(mf, "weights"))
    if (!is.null(weights) &amp;&amp; !is.numeric(weights)) 
        stop("'weights' must be a numeric vector")
    if (is.null(weights)) 
        weights &lt;- rep(as.numeric(1), dp.n)
    if (any(is.na(weights))) 
        stop("NAs in weights")
    if (any(weights &lt; 0)) 
        stop("negative weights")
    y &lt;- model.extract(mf, "response")
    x &lt;- model.matrix(mt, mf)
    n = dim(coords)[1]
    if (longlat) {
        D = as.matrix(earth.dist(coords), n, n)
    }
    else {
        Xmat = matrix(rep(coords[, 1], times = n), n, n)
        Ymat = matrix(rep(coords[, 2], times = n), n, n)
        D = sqrt((Xmat - t(Xmat))^2 + (Ymat - t(Ymat))^2)
    }
    if (nearest.neighbors) {
        beta1 &lt;- 0
        beta2 &lt;- 1
    }
    else {
        bbox &lt;- cbind(range(coords[, 1]), range(coords[, 2]))
        difmin &lt;- spDistsN1(bbox, bbox[2, ], longlat)[1]
        if (any(!is.finite(difmin))) 
            difmin[which(!is.finite(difmin))] &lt;- 0
        beta1 &lt;- difmin/1000
        beta2 &lt;- 2 * difmin
    }
    opt &lt;- optimize(gwglmnet.cv.f, lower = beta1, upper = beta2, 
        maximum = FALSE, tol = tol, formula = formula, coords = coords, 
        s = s, gweight = gweight, verbose = verbose, longlat = longlat, 
        data = data, D = D, weights = weights, adapt = adapt, 
        nn = nearest.neighbors, family = family)
    bdwt &lt;- opt$minimum
    res &lt;- bdwt
    res
  }
</pre>

<hr><div align="center">[Package <em>lagr</em> version 0.1 <a href="00Index.html">Index</a>]</div>
</body></html>
